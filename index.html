<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Caribbean Heat Stress Atlas — Puerto Rico</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100vh; width: 100vw; }

    /* Card-style controls + legend */
    .legend,
    .slider-wrap,
    .metric-wrap,
    .info-card {
      background:#fff;
      padding:8px 10px;
      border:1px solid #ccc;
      border-radius:6px;
      box-shadow:0 1px 3px rgba(0,0,0,.15);
      font:12px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      min-width:220px;
    }

    .legend {
      min-width: 180px;
    }

    .legend h4 { margin: 0 0 6px; font-size: 12px; }

    .slider-wrap .label,
    .metric-wrap .label {
      display:block;
      margin-bottom:6px;
      font-weight:600;
    }

    .slider-wrap input[type="range"] { width:100%; }
    .slider-wrap .value { font-variant-numeric: tabular-nums; }

    .metric-wrap select {
      width:100%;
      font-size:12px;
    }

    .info-card {
      max-width:260px;
    }

    .sparkline {
      margin-top:8px;
    }

    .sparkline .sparkline-wrap {
      width:240px;
      max-width:100%;
    }

    .sparkline canvas {
      display:block;
      width:100%;
      height:140px;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<script>
// ---------------------------------------------------------
// Caribbean Heat Stress Atlas — Temperature-only metrics
//
// Metrics per station & year (in stations_heatmetrics_all.geojson):
//   hot_days_32      : # days with Tmax ≥ 32 °C
//   hot_days_35      : # days with Tmax ≥ 35 °C
//   warm_nights_24   : # nights with Tmin ≥ 24 °C
//   oppressive_days  : # days with Tmax ≥ 32 °C AND Tmin ≥ 24 °C
//
//   hottest_month_index[year] : 1–12 (month with highest mean Tmax)
//   hottest_month_tmax[year]  : mean Tmax in that month (°C)
//   hottest_month_tmin[year]  : mean Tmin in that month (°C)
// ---------------------------------------------------------

// --- Map setup ---
const prCenter = [18.2208, -66.5901];
const map = L.map('map', { center: prCenter, zoom: 8 });

const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

L.control.scale({ metric:false, imperial:true }).addTo(map);

const baseLayers = { "OpenStreetMap": osm };
const overlays = {};
const layerControl = L.control.layers(baseLayers, overlays, { collapsed: false }).addTo(map);

// --- Globals for station data & time/metric state ---
let stationsData = null;
let stationLayer = null;

let YEARS = [];                     // filled after data loads
let currentYear = null;
let currentMetric = 'hot_days_32';  // default metric
let tempUnit = 'F';                 // 'F' or 'C' for display

const MONTH_NAMES = [null, 'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

function monthNameFromIndex(idx) {
  return MONTH_NAMES[idx] || `Month ${idx}`;
}

// --- Temperature helpers (display only, data stays in °C) ---
function cToF(c) {
  return c * 9/5 + 32;
}

function formatTemp(valC) {
  if (valC == null || Number.isNaN(valC)) return 'N/A';
  if (tempUnit === 'C') {
    return `${valC.toFixed(1)} °C`;
  } else {
    return `${cToF(valC).toFixed(1)} °F`;
  }
}

// Text labels depending on metric + unit
const METRIC_LABELS = {
  C: {
    hot_days_32: 'Hot days (Tmax ≥ 32 °C)',
    hot_days_35: 'Very hot days (Tmax ≥ 35 °C)',
    warm_nights_24: 'Warm nights (Tmin ≥ 24 °C)',
    oppressive_days: 'Oppressive days (Tmax ≥ 32 °C & Tmin ≥ 24 °C)'
  },
  F: {
    hot_days_32: 'Hot days (Tmax ≥ 90 °F)',
    hot_days_35: 'Very hot days (Tmax ≥ 95 °F)',
    warm_nights_24: 'Warm nights (Tmin ≥ 75 °F)',
    oppressive_days: 'Oppressive days (Tmax ≥ 90 °F & Tmin ≥ 75 °F)'
  }
};

const TEMP_THRESHOLDS = {
  C: { hot: 32, veryHot: 35, warmNight: 24 },
  F: { hot: 90, veryHot: 95, warmNight: 75 }
};

function metricLabel(metricKey) {
  const labels = METRIC_LABELS[tempUnit] || {};
  return labels[metricKey] || 'Days per year';
}

function legendTitleForMetric(metricKey) {
  return metricLabel(metricKey) + '<br/><small>(days per year)</small>';
}

function infoCardHTML() {
  const thresholds = TEMP_THRESHOLDS[tempUnit] || TEMP_THRESHOLDS.F;
  const unitLabel = tempUnit === 'C' ? '°C' : '°F';
  return `
    <strong>Caribbean Heat Stress Atlas — Puerto Rico</strong><br/>
    Daily max/min temperatures aggregated by year (1960–2025).<br/><br/>
    • Hot days: Tmax ≥ ${thresholds.hot} ${unitLabel}, very hot ≥ ${thresholds.veryHot} ${unitLabel}.<br/>
    • Warm nights: Tmin ≥ ${thresholds.warmNight} ${unitLabel}.<br/>
    • Oppressive days: Tmax ≥ ${thresholds.hot} ${unitLabel} & Tmin ≥ ${thresholds.warmNight} ${unitLabel}.<br/>
    Counts are per year at each station.
  `;
}

function updateMetricSelectLabels() {
  const sel = document.getElementById('metricSelect');
  if (!sel) return;
  for (const opt of sel.options) {
    opt.textContent = metricLabel(opt.value);
  }
}

// --- Legend ---
const legend = L.control({ position: 'bottomright' });
legend.onAdd = function () {
  const div = L.DomUtil.create('div', 'legend');
  div.innerHTML = `
    <h4>${legendTitleForMetric(currentMetric)}</h4>
    <div><span style="
      display:inline-block;width:14px;height:14px;
      background:#4575b4;border:1px solid #ccc;margin-right:6px;"></span>
      &lt; 30 days
    </div>
    <div><span style="
      display:inline-block;width:14px;height:14px;
      background:#91bfdb;border:1px solid #ccc;margin-right:6px;"></span>
      30 – 59 days
    </div>
    <div><span style="
      display:inline-block;width:14px;height:14px;
      background:#fee090;border:1px solid #ccc;margin-right:6px;"></span>
      60 – 89 days
    </div>
    <div><span style="
      display:inline-block;width:14px;height:14px;
      background:#fdae61;border:1px solid #ccc;margin-right:6px;"></span>
      90 – 119 days
    </div>
    <div><span style="
      display:inline-block;width:14px;height:14px;
      background:#d73027;border:1px solid #ccc;margin-right:6px;"></span>
      ≥ 120 days
    </div>
    <div style="margin-top:4px;"><span style="
      display:inline-block;width:14px;height:14px;
      background:#999999;border:1px solid #ccc;margin-right:6px;"></span>
      No data
    </div>
  `;
  return div;
};
legend.addTo(map);

function updateLegendTitle() {
  const h4 = document.querySelector('.legend h4');
  if (h4) h4.innerHTML = legendTitleForMetric(currentMetric);
}

// --- Info card (bottom-left) ---
const InfoCardControl = L.Control.extend({
  options: { position: 'bottomleft' },
  onAdd: function () {
    const div = L.DomUtil.create('div', 'info-card');
    div.id = 'infoCard';
    div.innerHTML = infoCardHTML();
    L.DomEvent.disableClickPropagation(div);
    L.DomEvent.disableScrollPropagation(div);
    return div;
  }
});
map.addControl(new InfoCardControl());

function updateInfoCard() {
  const div = document.getElementById('infoCard');
  if (div) div.innerHTML = infoCardHTML();
}

// --- Puerto Rico boundary ---
fetch('data/pr_boundary.geojson')
  .then(r => r.json())
  .then(geo => {
    const prBoundary = L.geoJSON(geo, {
      style: { color: '#333', weight: 2, fill: false },
      onEachFeature: (f, layer) => {
        const label = f?.properties?.name || 'Puerto Rico';
        layer.bindTooltip(label, { sticky: true });
      }
    }).addTo(map);

    layerControl.addOverlay(prBoundary, 'Puerto Rico boundary');
    map.fitBounds(prBoundary.getBounds(), { padding: [12, 12] });
  })
  .catch(err => console.error('Failed to load PR boundary:', err));

// --- Color scale (shared by all metrics) ---
function getColorForValue(v) {
  if (v == null || Number.isNaN(v)) return '#999999';   // no data
  if (v < 30)   return '#4575b4';   // < 30 days
  if (v < 60)   return '#91bfdb';   // 30–59
  if (v < 90)   return '#fee090';   // 60–89
  if (v < 120)  return '#fdae61';   // 90–119
  return '#d73027';                // ≥ 120
}

// --- Helpers for the station layer ---
function stationFilter(feature) {
  if (!currentYear || !currentMetric) return false;
  const m = feature.properties.metrics;
  if (!m || !m[currentMetric]) return false;
  const v = m[currentMetric][currentYear];
  return v != null && !Number.isNaN(v);
}

function stationPointToLayer(feature, latlng) {
  const v = feature.properties.metrics[currentMetric][currentYear];
  return L.circleMarker(latlng, {
    radius: 6,
    color: '#333',
    weight: 1,
    fillColor: getColorForValue(v),
    fillOpacity: 0.9
  });
}

function stationOnEachFeature(feature, layer) {
  const m = feature.properties.metrics;
  const vMain = m[currentMetric][currentYear];

  const hd32 = m.hot_days_32?.[currentYear];
  const hd35 = m.hot_days_35?.[currentYear];
  const wn24 = m.warm_nights_24?.[currentYear];
  const opp  = m.oppressive_days?.[currentYear];

  const hm_idx  = m.hottest_month_index?.[currentYear];
  const hm_tmax = m.hottest_month_tmax?.[currentYear];
  const hm_tmin = m.hottest_month_tmin?.[currentYear];

  const mainLabel = metricLabel(currentMetric);
  const chartId = `chart-${(feature.properties.id || feature.properties.name || 'st').toString().replace(/[^a-z0-9]+/gi,'-')}-${Math.random().toString(36).slice(2,7)}`;

  let popup = `
    <strong>${feature.properties.name}</strong><br/>
    ${feature.properties.country}<br/>
    Year: ${currentYear}<br/>
    ${mainLabel}: <strong>${vMain} days</strong>
  `;

  popup += '<hr style="margin:4px 0;">';
  if (hd32 != null) popup += `Hot days: ${hd32} days<br/>`;
  if (hd35 != null) popup += `Very hot days: ${hd35} days<br/>`;
  if (wn24 != null) popup += `Warm nights: ${wn24} nights<br/>`;
  if (opp  != null) popup += `Oppressive days: ${opp} days<br/>`;

  if (hm_idx != null && hm_tmax != null && hm_tmin != null) {
    popup += `
      <br/><em>Hottest month:</em> ${monthNameFromIndex(hm_idx)}<br/>
      Avg max: ${formatTemp(hm_tmax)}<br/>
      Avg min: ${formatTemp(hm_tmin)}
    `;
  }

  popup += `
    <div class="sparkline">
      <div style="font-size:11px;color:#555;margin-bottom:4px;">Trend across years</div>
      <div class="sparkline-wrap">
        <canvas id="${chartId}"></canvas>
      </div>
      <div id="${chartId}-fallback" style="display:none;font-size:11px;color:#777;">No data to plot.</div>
    </div>
  `;

  layer.bindPopup(popup);
  layer.on('popupopen', () => renderStationChart(feature, chartId));
}

// Clear & refill the existing stationLayer while keeping the overlay toggle state
function redrawStations() {
  if (!stationsData || !stationLayer) return;
  stationLayer.clearLayers();
  stationLayer.addData(stationsData);
}

function drawStationsForYear(year) {
  currentYear = year;
  redrawStations();
}

// --- Time slider control ---
const SliderControl = L.Control.extend({
  options: { position: 'topright' },
  onAdd: function () {
    const wrap = L.DomUtil.create('div', 'slider-wrap');
    wrap.innerHTML = `
      <span class="label">Time</span>
      <input id="timeRange" type="range" min="0" max="0" value="0" disabled />
      <span class="value" id="timeLabel">Not available</span>
    `;
    L.DomEvent.disableClickPropagation(wrap);
    L.DomEvent.disableScrollPropagation(wrap);
    return wrap;
  }
});
map.addControl(new SliderControl());

function initTimeSlider(years) {
  const range = document.getElementById('timeRange');
  const label = document.getElementById('timeLabel');

  if (!range || !label) {
    console.warn('Time slider elements not found in DOM');
    return;
  }

  range.disabled = false;
  range.min = 0;
  range.max = years.length - 1;
  range.value = 0;

  label.textContent = years[0];

  range.addEventListener('input', () => {
    const idx = Number(range.value);
    const year = years[idx];
    label.textContent = year;
    console.log('Selected year:', year);
    drawStationsForYear(year);
  });
}

// --- Metric selector control ---
const MetricControl = L.Control.extend({
  options: { position: 'topright' },
  onAdd: function () {
    const wrap = L.DomUtil.create('div', 'metric-wrap');
    wrap.innerHTML = `
      <span class="label">Metric</span>
      <select id="metricSelect">
        <option value="hot_days_32"></option>
        <option value="hot_days_35"></option>
        <option value="warm_nights_24"></option>
        <option value="oppressive_days"></option>
      </select>
    `;
    L.DomEvent.disableClickPropagation(wrap);
    L.DomEvent.disableScrollPropagation(wrap);
    return wrap;
  }
});
map.addControl(new MetricControl());

function initMetricSelector() {
  const select = document.getElementById('metricSelect');
  if (!select) return;

  select.value = currentMetric;
  updateMetricSelectLabels();

  select.addEventListener('change', () => {
    currentMetric = select.value;
    updateLegendTitle();
    redrawStations();   // same layer, new metric
  });
}

// --- Temperature units control (°F / °C) ---
const UnitControl = L.Control.extend({
  options: { position: 'topright' },
  onAdd: function () {
    const wrap = L.DomUtil.create('div', 'metric-wrap');
    wrap.innerHTML = `
      <span class="label">Temperature units</span>
      <select id="tempUnitSelect">
        <option value="F">°F (Fahrenheit)</option>
        <option value="C">°C (Celsius)</option>
      </select>
    `;
    L.DomEvent.disableClickPropagation(wrap);
    L.DomEvent.disableScrollPropagation(wrap);
    return wrap;
  }
});
map.addControl(new UnitControl());

function initUnitSelector() {
  const sel = document.getElementById('tempUnitSelect');
  if (!sel) return;
  sel.value = tempUnit;
  sel.addEventListener('change', () => {
    tempUnit = sel.value;
    updateLegendTitle();
    updateMetricSelectLabels();
    updateInfoCard();
  
  });
}

// Wait a tick so Leaflet has added the control DOM
setTimeout(() => {
  initMetricSelector();
  initUnitSelector();
}, 0);

// Build a small per-station time series trend line for the active metric
function renderStationChart(feature, canvasId) {
  const canvas = document.getElementById(canvasId);
  const fallback = document.getElementById(`${canvasId}-fallback`);
  if (!canvas) return;

  const metricsForStation = feature.properties.metrics?.[currentMetric] || {};
  const labels = [];
  const data = [];
  for (const y of YEARS) {
    const v = metricsForStation[y];
    if (v != null && !Number.isNaN(v)) {
      labels.push(y);
      data.push(v);
    }
  }

  if (!labels.length) {
    if (fallback) fallback.style.display = 'block';
    return;
  }

  if (canvas.chartInstance) {
    canvas.chartInstance.destroy();
  }

  const ctx = canvas.getContext('2d');
  canvas.chartInstance = new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [{
        label: metricLabel(currentMetric),
        data,
        borderColor: '#d73027',
        backgroundColor: 'rgba(215,48,39,0.15)',
        borderWidth: 2,
        tension: 0.25,
        pointRadius: 0,
        fill: true
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.parsed.y} days (${ctx.label})`
          }
        }
      },
      scales: {
        x: {
          ticks: { maxTicksLimit: 6 }
        },
        y: {
          beginAtZero: true
        }
      }
    }
  });
}

// --- Load stations with all metrics ---
fetch('data/stations_heatmetrics_all.geojson')
  .then(r => r.json())
  .then(geo => {
    stationsData = geo;
    console.log('Loaded stations metrics:', stationsData);

    if (!stationsData.features.length) {
      console.warn('No features in stations_heatmetrics_all.geojson');
      return;
    }

    // Use hot_days_32 (or 35) of first feature to infer year range
    const firstMetrics = stationsData.features[0].properties.metrics;
    const ref = firstMetrics.hot_days_32 || firstMetrics.hot_days_35;
    YEARS = Object.keys(ref).sort();
    currentYear = YEARS[0];

    // Create a single persistent station layer and register it as overlay
    stationLayer = L.geoJSON(null, {
      filter: stationFilter,
      pointToLayer: stationPointToLayer,
      onEachFeature: stationOnEachFeature
    });

    layerControl.addOverlay(stationLayer, 'Temperature metrics (days per year)');
    stationLayer.addTo(map);  // default: visible

    // Fill it with data for the initial year/metric
    redrawStations();
    initTimeSlider(YEARS);
  })
  .catch(err => console.error('Failed to load stations metrics:', err));

</script>

</body>
</html>
