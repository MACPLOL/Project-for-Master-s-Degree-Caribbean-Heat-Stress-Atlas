<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Caribbean Heat Stress Atlas — Puerto Rico</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="preconnect" href="https://fonts.googleapis.com"/>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin/>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:wght@400;500;600;700&family=Fraunces:opsz,wght@9..144,500;600&display=swap"/>

  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100vh; width: 100vw; }

    :root {
      --ui-font: "Bricolage Grotesque", "IBM Plex Sans", "Noto Sans", sans-serif;
      --ui-title-font: "Fraunces", "Iowan Old Style", "Palatino Linotype", serif;
      --ui-bg: rgba(255, 255, 255, 0.92);
      --ui-bg-2: rgba(255, 245, 236, 0.96);
      --ui-border: rgba(0, 0, 0, 0.08);
      --ui-shadow: 0 14px 35px rgba(0, 0, 0, 0.18);
      --ui-radius: 14px;
      --ui-accent: #e76f51;
      --ui-accent-2: #f4a261;
      --ui-text: #1f2937;
      --ui-muted: #4b5563;
    }

    /* Card-style controls + legend */
    .legend,
    .slider-wrap,
    .metric-wrap,
    .info-card {
      background: linear-gradient(135deg, var(--ui-bg), var(--ui-bg-2));
      color: var(--ui-text);
      padding:10px 12px;
      border:1px solid var(--ui-border);
      border-radius: var(--ui-radius);
      box-shadow: var(--ui-shadow);
      font: 12.5px/1.3 var(--ui-font);
      min-width:220px;
      backdrop-filter: blur(6px);
      position: relative;
      overflow: hidden;
    }

    .legend::before,
    .slider-wrap::before,
    .metric-wrap::before,
    .info-card::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--ui-accent), var(--ui-accent-2));
    }

    .legend {
      min-width: 180px;
    }

    .legend h4 {
      margin: 2px 0 8px;
      font-size: 13px;
      font-family: var(--ui-title-font);
      letter-spacing: 0.01em;
    }

    .legend div {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .slider-wrap .label,
    .metric-wrap .label {
      display:block;
      margin-bottom:6px;
      font-weight:600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 10px;
      color: var(--ui-muted);
    }

    .slider-wrap input[type="range"] {
      width:100%;
      accent-color: var(--ui-accent);
    }
    .slider-wrap .value {
      font-variant-numeric: tabular-nums;
      font-weight: 600;
    }
    .slider-wrap.is-static input[type="range"] { display: none; }
    .slider-wrap.is-static .value { font-weight: 600; }

    .metric-wrap select {
      width:100%;
      font-size:12.5px;
      font-family: var(--ui-font);
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid var(--ui-border);
      background: #fff;
      color: var(--ui-text);
    }

    .reset-wrap button {
      width: 100%;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid var(--ui-border);
      background: #fff;
      color: var(--ui-text);
      font: 600 12px/1 var(--ui-font);
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .reset-wrap button:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.12);
    }

    .info-card {
      max-width:260px;
    }

    .sparkline {
      margin-top:8px;
    }

    .sparkline .sparkline-wrap {
      width:240px;
      max-width:100%;
    }

    .sparkline canvas {
      display:block;
      width:100%;
      height:140px;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<script>
// ---------------------------------------------------------
// Caribbean Heat Stress Atlas — Temperature-only metrics
//
// Metrics per station & year (in stations_heatmetrics_all.geojson):
//   hot_days_32      : # days with Tmax ≥ 32 °C
//   hot_days_35      : # days with Tmax ≥ 35 °C
//   warm_nights_24   : # nights with Tmin ≥ 24 °C
//   oppressive_days  : # days with Tmax ≥ 32 °C AND Tmin ≥ 24 °C
//
//   hottest_month_index[year] : 1–12 (month with highest mean Tmax)
//   hottest_month_tmax[year]  : mean Tmax in that month (°C)
//   hottest_month_tmin[year]  : mean Tmin in that month (°C)
// ---------------------------------------------------------

// --- Map setup ---
const prCenter = [18.2208, -66.5901];
const map = L.map('map', { center: prCenter, zoom: 8 });

const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

L.control.scale({ metric:false, imperial:true }).addTo(map);

const baseLayers = { "OpenStreetMap": osm };
const overlays = {};
const layerControl = L.control.layers(baseLayers, overlays, { collapsed: false }).addTo(map);

// --- Globals for station data & time/metric state ---
let stationsData = null;
let stationLayer = null;

let YEARS = [];                     // filled after data loads
let currentYear = null;
let currentMetric = 'hot_days_32';  // default metric
let tempUnit = 'F';                 // 'F' or 'C' for display

const MONTH_NAMES = [null, 'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
const DELTA_YEAR_KEY = 'late_minus_early';
const DELTA_PERIODS = {
  early: { start: 1961, end: 1980 },
  late: { start: 2006, end: 2025 }
};

function monthNameFromIndex(idx) {
  return MONTH_NAMES[idx] || `Month ${idx}`;
}

// --- Temperature helpers (display only, data stays in °C) ---
function cToF(c) {
  return c * 9/5 + 32;
}

function formatTemp(valC) {
  if (valC == null || Number.isNaN(valC)) return 'N/A';
  if (tempUnit === 'C') {
    return `${valC.toFixed(1)} °C`;
  } else {
    return `${cToF(valC).toFixed(1)} °F`;
  }
}

function averageForPeriod(metricByYear, startYear, endYear) {
  if (!metricByYear) return null;
  let sum = 0;
  let count = 0;
  for (const [yearStr, val] of Object.entries(metricByYear)) {
    const year = Number(yearStr);
    if (!Number.isFinite(year)) continue;
    if (year < startYear || year > endYear) continue;
    if (val == null || Number.isNaN(val)) continue;
    sum += val;
    count += 1;
  }
  if (!count) return null;
  return sum / count;
}

function computeDeltaMetric(metrics, baseKey) {
  const byYear = metrics?.[baseKey];
  if (!byYear) return null;
  const earlyAvg = averageForPeriod(byYear, DELTA_PERIODS.early.start, DELTA_PERIODS.early.end);
  const lateAvg = averageForPeriod(byYear, DELTA_PERIODS.late.start, DELTA_PERIODS.late.end);
  if (earlyAvg == null || lateAvg == null) return null;
  return Number((lateAvg - earlyAvg).toFixed(1));
}

function getDeltaMetricValue(metrics, metricKey) {
  if (!metrics) return null;
  const cached = metrics[metricKey]?.[DELTA_YEAR_KEY];
  if (cached != null && !Number.isNaN(cached)) return cached;
  const baseKey = metricKey.replace(/^delta_/, '');
  const delta = computeDeltaMetric(metrics, baseKey);
  if (delta == null) return null;
  metrics[metricKey] = { [DELTA_YEAR_KEY]: delta };
  return delta;
}

// Text labels depending on metric + unit
const METRIC_LABELS = {
  C: {
    hot_days_32: 'Hot days (Tmax ≥ 32 °C)',
    hot_days_35: 'Very hot days (Tmax ≥ 35 °C)',
    warm_nights_24: 'Warm nights (Tmin ≥ 24 °C)',
    oppressive_days: 'Oppressive days (Tmax ≥ 32 °C & Tmin ≥ 24 °C)',
    delta_hot_days_32: 'Change in hot days (late − early)',
    delta_warm_nights_24: 'Change in warm nights (late − early)'
  },
  F: {
    hot_days_32: 'Hot days (Tmax ≥ 90 °F)',
    hot_days_35: 'Very hot days (Tmax ≥ 95 °F)',
    warm_nights_24: 'Warm nights (Tmin ≥ 75 °F)',
    oppressive_days: 'Oppressive days (Tmax ≥ 90 °F & Tmin ≥ 75 °F)',
    delta_hot_days_32: 'Change in hot days (late − early)',
    delta_warm_nights_24: 'Change in warm nights (late − early)'
  }
};

const TEMP_THRESHOLDS = {
  C: { hot: 32, veryHot: 35, warmNight: 24 },
  F: { hot: 90, veryHot: 95, warmNight: 75 }
};

function metricLabel(metricKey) {
  const labels = METRIC_LABELS[tempUnit] || {};
  return labels[metricKey] || 'Days per year';
}

function legendTitleForMetric(metricKey) {
  if (metricKey.startsWith('delta_')) {
    return metricLabel(metricKey) + '<br/><small>(days per year)</small>';
  }
  return metricLabel(metricKey) + '<br/><small>(days per year)</small>';
}

function infoCardHTML() {
  const thresholds = TEMP_THRESHOLDS[tempUnit] || TEMP_THRESHOLDS.F;
  const unitLabel = tempUnit === 'C' ? '°C' : '°F';
  return `
    <strong>Caribbean Heat Stress Atlas — Puerto Rico</strong><br/>
    <span style="font-size:11px;color:var(--ui-muted);">Made by Mauro A. Collazo Pabón 2025-2026</span><br/>
    Daily max/min temperatures aggregated by year (1960–2025).<br/><br/>
    • Hot days: Tmax ≥ ${thresholds.hot} ${unitLabel}, very hot ≥ ${thresholds.veryHot} ${unitLabel}.<br/>
    • Warm nights: Tmin ≥ ${thresholds.warmNight} ${unitLabel}.<br/>
    • Oppressive days: Tmax ≥ ${thresholds.hot} ${unitLabel} & Tmin ≥ ${thresholds.warmNight} ${unitLabel}.<br/>
    • Change metrics compare 2006–2025 vs 1961–1980.<br/>
    Counts are per year at each station.
  `;
}

function updateMetricSelectLabels() {
  const sel = document.getElementById('metricSelect');
  if (!sel) return;
  for (const opt of sel.options) {
    opt.textContent = metricLabel(opt.value);
  }
}

// --- Legend ---
function legendHTML(metricKey) {
  if (metricKey.startsWith('delta_')) {
    return `
      <h4>${legendTitleForMetric(metricKey)}</h4>
      <div><span style="
        display:inline-block;width:14px;height:14px;
        background:#2166ac;border:1px solid #ccc;margin-right:6px;"></span>
        ≤ −40 days
      </div>
      <div><span style="
        display:inline-block;width:14px;height:14px;
        background:#67a9cf;border:1px solid #ccc;margin-right:6px;"></span>
        −39 to −20
      </div>
      <div><span style="
        display:inline-block;width:14px;height:14px;
        background:#d1e5f0;border:1px solid #ccc;margin-right:6px;"></span>
        −19 to −1
      </div>
      <div><span style="
        display:inline-block;width:14px;height:14px;
        background:#fddbc7;border:1px solid #ccc;margin-right:6px;"></span>
        0 to 19
      </div>
      <div><span style="
        display:inline-block;width:14px;height:14px;
        background:#ef8a62;border:1px solid #ccc;margin-right:6px;"></span>
        20 to 39
      </div>
      <div><span style="
        display:inline-block;width:14px;height:14px;
        background:#b2182b;border:1px solid #ccc;margin-right:6px;"></span>
        ≥ 40 days
      </div>
      <div style="margin-top:4px;"><span style="
        display:inline-block;width:14px;height:14px;
        background:#999999;border:1px solid #ccc;margin-right:6px;"></span>
        No data
      </div>
    `;
  }

  return `
    <h4>${legendTitleForMetric(metricKey)}</h4>
    <div><span style="
      display:inline-block;width:14px;height:14px;
      background:#4575b4;border:1px solid #ccc;margin-right:6px;"></span>
      &lt; 30 days
    </div>
    <div><span style="
      display:inline-block;width:14px;height:14px;
      background:#91bfdb;border:1px solid #ccc;margin-right:6px;"></span>
      30 – 59 days
    </div>
    <div><span style="
      display:inline-block;width:14px;height:14px;
      background:#fee090;border:1px solid #ccc;margin-right:6px;"></span>
      60 – 89 days
    </div>
    <div><span style="
      display:inline-block;width:14px;height:14px;
      background:#fdae61;border:1px solid #ccc;margin-right:6px;"></span>
      90 – 119 days
    </div>
    <div><span style="
      display:inline-block;width:14px;height:14px;
      background:#d73027;border:1px solid #ccc;margin-right:6px;"></span>
      ≥ 120 days
    </div>
    <div style="margin-top:4px;"><span style="
      display:inline-block;width:14px;height:14px;
      background:#999999;border:1px solid #ccc;margin-right:6px;"></span>
      No data
    </div>
  `;
}

const legend = L.control({ position: 'bottomright' });
legend.onAdd = function () {
  const div = L.DomUtil.create('div', 'legend');
  div.innerHTML = legendHTML(currentMetric);
  return div;
};
legend.addTo(map);

function updateLegendTitle() {
  const div = document.querySelector('.legend');
  if (div) div.innerHTML = legendHTML(currentMetric);
}

// --- Info card (bottom-left) ---
const InfoCardControl = L.Control.extend({
  options: { position: 'bottomleft' },
  onAdd: function () {
    const div = L.DomUtil.create('div', 'info-card');
    div.id = 'infoCard';
    div.innerHTML = infoCardHTML();
    L.DomEvent.disableClickPropagation(div);
    L.DomEvent.disableScrollPropagation(div);
    return div;
  }
});
map.addControl(new InfoCardControl());

function updateInfoCard() {
  const div = document.getElementById('infoCard');
  if (div) div.innerHTML = infoCardHTML();
}

// --- Puerto Rico boundary ---
fetch('data/pr_boundary.geojson')
  .then(r => r.json())
  .then(geo => {
    const prBoundary = L.geoJSON(geo, {
      style: { color: '#333', weight: 2, fill: false },
      onEachFeature: (f, layer) => {
        const label = f?.properties?.name || 'Puerto Rico';
        layer.bindTooltip(label, { sticky: true });
      }
    }).addTo(map);

    layerControl.addOverlay(prBoundary, 'Puerto Rico boundary');
    map.fitBounds(prBoundary.getBounds(), { padding: [12, 12] });
  })
  .catch(err => console.error('Failed to load PR boundary:', err));

// --- Color scale (shared by all metrics) ---
function getColorForValue(v) {
  if (v == null || Number.isNaN(v)) return '#999999';   // no data
  if (currentMetric.startsWith('delta_')) {
    if (v <= -40) return '#2166ac';
    if (v <= -20) return '#67a9cf';
    if (v < 0) return '#d1e5f0';
    if (v < 20) return '#fddbc7';
    if (v < 40) return '#ef8a62';
    return '#b2182b';
  }
  if (v < 30)   return '#4575b4';   // < 30 days
  if (v < 60)   return '#91bfdb';   // 30–59
  if (v < 90)   return '#fee090';   // 60–89
  if (v < 120)  return '#fdae61';   // 90–119
  return '#d73027';                // ≥ 120
}

function metricValue(feature) {
  const m = feature.properties.metrics;
  if (!m) return null;
  if (currentMetric.startsWith('delta_')) {
    return getDeltaMetricValue(m, currentMetric);
  }
  const metricByYear = m[currentMetric];
  if (!metricByYear) return null;
  return metricByYear[currentYear];
}

// --- Helpers for the station layer ---
function stationFilter(feature) {
  if (!currentYear || !currentMetric) return false;
  const v = metricValue(feature);
  return v != null && !Number.isNaN(v);
}

function stationPointToLayer(feature, latlng) {
  const v = metricValue(feature);
  return L.circleMarker(latlng, {
    radius: 6,
    color: '#333',
    weight: 1,
    fillColor: getColorForValue(v),
    fillOpacity: 0.9
  });
}

function stationOnEachFeature(feature, layer) {
  const m = feature.properties.metrics;
  const vMain = metricValue(feature);

  const hd32 = m.hot_days_32?.[currentYear];
  const hd35 = m.hot_days_35?.[currentYear];
  const wn24 = m.warm_nights_24?.[currentYear];
  const opp  = m.oppressive_days?.[currentYear];

  const hm_idx  = m.hottest_month_index?.[currentYear];
  const hm_tmax = m.hottest_month_tmax?.[currentYear];
  const hm_tmin = m.hottest_month_tmin?.[currentYear];

  const mainLabel = metricLabel(currentMetric);
  const chartId = `chart-${(feature.properties.id || feature.properties.name || 'st').toString().replace(/[^a-z0-9]+/gi,'-')}-${Math.random().toString(36).slice(2,7)}`;

  let popup = `
    <strong>${feature.properties.name}</strong><br/>
    ${feature.properties.country}<br/>
    ${currentMetric.startsWith('delta_') ? 'Period: 2006–2025 minus 1961–1980' : `Year: ${currentYear}`}<br/>
    ${mainLabel}: <strong>${vMain} days</strong>
  `;

  popup += '<hr style="margin:4px 0;">';
  if (hd32 != null) popup += `Hot days: ${hd32} days<br/>`;
  if (hd35 != null) popup += `Very hot days: ${hd35} days<br/>`;
  if (wn24 != null) popup += `Warm nights: ${wn24} nights<br/>`;
  if (opp  != null) popup += `Oppressive days: ${opp} days<br/>`;

  if (hm_idx != null && hm_tmax != null && hm_tmin != null) {
    popup += `
      <br/><em>Hottest month:</em> ${monthNameFromIndex(hm_idx)}<br/>
      Avg max: ${formatTemp(hm_tmax)}<br/>
      Avg min: ${formatTemp(hm_tmin)}
    `;
  }

  if (!currentMetric.startsWith('delta_')) {
    popup += `
      <div class="sparkline">
        <div style="font-size:11px;color:#555;margin-bottom:4px;">Trend across years</div>
        <div class="sparkline-wrap">
          <canvas id="${chartId}"></canvas>
        </div>
        <div id="${chartId}-fallback" style="display:none;font-size:11px;color:#777;">No data to plot.</div>
      </div>
    `;
  }

  layer.bindPopup(popup);
  if (!currentMetric.startsWith('delta_')) {
    layer.on('popupopen', () => renderStationChart(feature, chartId));
  }
}

// Clear & refill the existing stationLayer while keeping the overlay toggle state
function redrawStations() {
  if (!stationsData || !stationLayer) return;
  stationLayer.clearLayers();
  stationLayer.addData(stationsData);
}

function drawStationsForYear(year) {
  currentYear = year;
  redrawStations();
}

// --- Time slider control ---
const SliderControl = L.Control.extend({
  options: { position: 'topright' },
  onAdd: function () {
    const wrap = L.DomUtil.create('div', 'slider-wrap');
    wrap.innerHTML = `
      <span class="label">Time</span>
      <input id="timeRange" type="range" min="0" max="0" value="0" disabled />
      <span class="value" id="timeLabel">Not available</span>
    `;
    L.DomEvent.disableClickPropagation(wrap);
    L.DomEvent.disableScrollPropagation(wrap);
    return wrap;
  }
});
map.addControl(new SliderControl());

function initTimeSlider(years) {
  const range = document.getElementById('timeRange');
  const label = document.getElementById('timeLabel');

  if (!range || !label) {
    console.warn('Time slider elements not found in DOM');
    return;
  }

  range.disabled = false;
  range.min = 0;
  range.max = years.length - 1;
  range.value = 0;

  label.textContent = years[0];

  range.addEventListener('input', () => {
    const idx = Number(range.value);
    const year = years[idx];
    label.textContent = year;
    console.log('Selected year:', year);
    drawStationsForYear(year);
  });

  updateTimeSliderAvailability();
}

function updateTimeSliderAvailability() {
  const range = document.getElementById('timeRange');
  const label = document.getElementById('timeLabel');
  if (!range || !label) return;
  const wrap = range.closest('.slider-wrap');
  if (currentMetric.startsWith('delta_')) {
    range.disabled = true;
    if (wrap) wrap.classList.add('is-static');
    label.textContent = '2006–2025 minus 1961–1980';
  } else {
    range.disabled = false;
    if (wrap) wrap.classList.remove('is-static');
    const idx = Number(range.value);
    label.textContent = YEARS[idx] || currentYear || 'Not available';
  }
}

// --- Metric selector control ---
const MetricControl = L.Control.extend({
  options: { position: 'topright' },
  onAdd: function () {
    const wrap = L.DomUtil.create('div', 'metric-wrap');
    wrap.innerHTML = `
      <span class="label">Metric</span>
      <select id="metricSelect">
        <option value="hot_days_32"></option>
        <option value="hot_days_35"></option>
        <option value="warm_nights_24"></option>
        <option value="oppressive_days"></option>
        <option value="delta_hot_days_32"></option>
        <option value="delta_warm_nights_24"></option>
      </select>
    `;
    L.DomEvent.disableClickPropagation(wrap);
    L.DomEvent.disableScrollPropagation(wrap);
    return wrap;
  }
});
map.addControl(new MetricControl());

function initMetricSelector() {
  const select = document.getElementById('metricSelect');
  if (!select) return;

  select.value = currentMetric;
  updateMetricSelectLabels();

  select.addEventListener('change', () => {
    currentMetric = select.value;
    updateLegendTitle();
    updateTimeSliderAvailability();
    redrawStations();   // same layer, new metric
  });
}

// --- Temperature units control (°F / °C) ---
const UnitControl = L.Control.extend({
  options: { position: 'topright' },
  onAdd: function () {
    const wrap = L.DomUtil.create('div', 'metric-wrap');
    wrap.innerHTML = `
      <span class="label">Temperature units</span>
      <select id="tempUnitSelect">
        <option value="F">°F (Fahrenheit)</option>
        <option value="C">°C (Celsius)</option>
      </select>
    `;
    L.DomEvent.disableClickPropagation(wrap);
    L.DomEvent.disableScrollPropagation(wrap);
    return wrap;
  }
});
map.addControl(new UnitControl());

function initUnitSelector() {
  const sel = document.getElementById('tempUnitSelect');
  if (!sel) return;
  sel.value = tempUnit;
  sel.addEventListener('change', () => {
    tempUnit = sel.value;
    updateLegendTitle();
    updateMetricSelectLabels();
    updateInfoCard();
  
  });
}

// --- Reset view button control ---
const ResetControl = L.Control.extend({
  options: { position: 'topright' },
  onAdd: function () {
    const wrap = L.DomUtil.create('div', 'metric-wrap reset-wrap');
    wrap.innerHTML = `<button type="button" id="resetViewBtn">Reset view</button>`;
    L.DomEvent.disableClickPropagation(wrap);
    L.DomEvent.disableScrollPropagation(wrap);
    return wrap;
  }
});
map.addControl(new ResetControl());

function initResetButton() {
  const btn = document.getElementById('resetViewBtn');
  if (!btn) return;
  btn.addEventListener('click', () => {
    map.setView(prCenter, 8);
  });
}

// Wait a tick so Leaflet has added the control DOM
setTimeout(() => {
  initMetricSelector();
  initUnitSelector();
  initResetButton();
}, 0);

// Build a small per-station time series trend line for the active metric
function renderStationChart(feature, canvasId) {
  const canvas = document.getElementById(canvasId);
  const fallback = document.getElementById(`${canvasId}-fallback`);
  if (!canvas) return;

  const metricsForStation = feature.properties.metrics?.[currentMetric] || {};
  const labels = [];
  const data = [];
  for (const y of YEARS) {
    const v = metricsForStation[y];
    if (v != null && !Number.isNaN(v)) {
      labels.push(y);
      data.push(v);
    }
  }

  if (!labels.length) {
    if (fallback) fallback.style.display = 'block';
    return;
  }

  if (canvas.chartInstance) {
    canvas.chartInstance.destroy();
  }

  const ctx = canvas.getContext('2d');
  canvas.chartInstance = new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [{
        label: metricLabel(currentMetric),
        data,
        borderColor: '#d73027',
        backgroundColor: 'rgba(215,48,39,0.15)',
        borderWidth: 2,
        tension: 0.25,
        pointRadius: 0,
        fill: true
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.parsed.y} days (${ctx.label})`
          }
        }
      },
      scales: {
        x: {
          ticks: { maxTicksLimit: 6 }
        },
        y: {
          beginAtZero: true
        }
      }
    }
  });
}

// --- Load stations with all metrics ---
fetch('data/stations_heatmetrics_all.geojson')
  .then(r => r.json())
  .then(geo => {
    stationsData = geo;
    console.log('Loaded stations metrics:', stationsData);

    if (!stationsData.features.length) {
      console.warn('No features in stations_heatmetrics_all.geojson');
      return;
    }

    // Use hot_days_32 (or 35) of first feature to infer year range
    const firstMetrics = stationsData.features[0].properties.metrics;
    const ref = firstMetrics.hot_days_32 || firstMetrics.hot_days_35;
    YEARS = Object.keys(ref).sort();
    currentYear = YEARS[0];

    // Create a single persistent station layer and register it as overlay
    stationLayer = L.geoJSON(null, {
      filter: stationFilter,
      pointToLayer: stationPointToLayer,
      onEachFeature: stationOnEachFeature
    });

    layerControl.addOverlay(stationLayer, 'Temperature metrics (days per year)');
    stationLayer.addTo(map);  // default: visible

    // Fill it with data for the initial year/metric
    redrawStations();
    initTimeSlider(YEARS);
  })
  .catch(err => console.error('Failed to load stations metrics:', err));

</script>

</body>
</html>
